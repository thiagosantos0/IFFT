{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org. IFFT is a Python linter to help you handle correlated changes across your codebase.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. You can find all helper methods defined by the \"ifft_core\" module here. You'll find detailed information about the method signatures, return types, exceptions, and examples.</p> <p>The module contains the following functions:</p> <ul> <li><code>get_modified_lines(repo, filename) - Get a set of modified lines for the given filename.</code></li> <li><code>scan_file(project_path, filename, modified_lines_set) - Scan the file for IFFT blocks and return the results.</code></li> <li><code>scan_files(project_path, dir_path_mock_project) - Scan the repository for modified Python files and return the results in a dictionary.</code></li> <li><code>validate_associated_file(associated_file_name)</code> - Validade if the associated file specified in IFFT block exists.</li> </ul>"},{"location":"reference/#note-for-the-examples-in-this-documentation-the-plus-sign-indicates-a-modified-line","title":"Note: For the examples in this documentation, the plus sign (+) indicates a modified line.","text":""},{"location":"reference/#ifft_core.ifft_parser.get_modified_lines","title":"<code>get_modified_lines(repo, filename)</code>","text":"<p>Get a set of modified lines for the given filename.</p> Example <p>file1.py:</p> <pre><code>+ line1\n\n+ line2\n\n+ line3\n</code></pre> <p>get_modified_lines(repo, file1.py)</p> <p>{'line1', 'line2', 'line3'}</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>A string corresponding to the repository.</p> required <code>filename</code> <code>str</code> <p>A string corresponding to the filename.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of modified lines.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def get_modified_lines(repo: str, filename: str) -&gt; set:\n    \"\"\"\n        Get a set of modified lines for the given filename.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                + line1\\n\n                + line2\\n\n                + line3\n\n            &gt;&gt;&gt;get_modified_lines(repo, file1.py)\\n\n            {'line1', 'line2', 'line3'}\n\n        Args:\n            repo (str): A string corresponding to the repository.\n            filename (str): A string corresponding to the filename.\n\n        Returns:\n            set: A set of modified lines.\n\n    \"\"\"\n    modified_lines = set()\n    diff_text = repo.git.diff(None, filename)\n    for line in diff_text.split('\\n'):\n        if line.startswith('+') and not line.startswith('+++'):\n            modified_lines.add(line[1:].strip())\n    print(f\"{Fore.GREEN} Modified lines: {modified_lines} {Style.RESET_ALL}\")\n    return modified_lines\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.scan_file","title":"<code>scan_file(project_path, filename, modified_lines_set)</code>","text":"<p>Scan the file for IFFT blocks and return the results.</p> Example <p>file1.py:</p> <pre><code>#IFFT.If\n\n    + line1\n\n    + line2\n\n    + line3\n#IFFT.Then(\"foo_file.py\", \"foo_label\")\n</code></pre> <p>scan_file(project_path, file1.py, {'line1', 'line2', 'line3'})</p> <pre><code>[{'block_content': '...',\n  'associated_file_name': 'foo_file.py',\n  'associated_file_label': 'foo_label',\n  'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>A string corresponding to the project path.</p> required <code>filename</code> <code>str</code> <p>A string corresponding to the filename.</p> required <code>modified_lines_set</code> <code>set</code> <p>A set of modified lines.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of results.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def scan_file(project_path: str, filename: str, modified_lines_set: set) -&gt; list:\n    \"\"\"\n        Scan the file for IFFT blocks and return the results.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                #IFFT.If\\n\n                    + line1\\n\n                    + line2\\n\n                    + line3\n                #IFFT.Then(\"foo_file.py\", \"foo_label\")\n\n            &gt;&gt;&gt;scan_file(project_path, file1.py, {'line1', 'line2', 'line3'})\\n\n                [{'block_content': '...',\n                  'associated_file_name': 'foo_file.py',\n                  'associated_file_label': 'foo_label',\n                  'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n\n        Args:\n            project_path (str): A string corresponding to the project path.\n            filename (str): A string corresponding to the filename.\n            modified_lines_set (set): A set of modified lines.\n\n        Returns:\n            list: A list of results.\n\n    \"\"\"\n\n    results = []\n    in_block = False\n    block_content = \"\"\n    associated_file = \"\"\n    block_start = 0\n    block_end = 0\n    modified_lines_within_blocks = []\n\n    logging.debug(f\"{Fore.GREEN} Scanning file: {filename} {Style.RESET_ALL}\")\n    file_path = os.path.join(project_path, filename)\n    logging.debug(f\"{Fore.GREEN} File path: {file_path} {Style.RESET_ALL}\")\n\n    lines = open(file_path).readlines()\n\n    for line_number, line in enumerate(lines):\n        if line.strip().startswith(\"#IFFT.If\"):\n            logging.debug(f\"{Fore.GREEN} Entering IFFT block {line} {Style.RESET_ALL}\")\n            in_block = True\n            block_start = line_number\n            block_content += line\n        elif line.strip().startswith(\"#IFFT.Then\"):\n            logging.info(f\"{Fore.YELLOW} Exiting IFFT block {line} + {Style.RESET_ALL}\")\n            associated_file = line.strip().split('(')[1].split(')')[0]\n            associated_file_name = associated_file.split(',')[0]\n            associated_file_label = associated_file.split(',')[1].strip()\n            valid_associated_file = validate_associated_file(associated_file_name)\n            if not valid_associated_file:\n                associated_file_name = \"\"\n                associated_file_label = \"\"\n            logging.info(f\"{Fore.YELLOW} Associated file name: {associated_file_name} {Style.RESET_ALL}\")\n            logging.info(f\"{Fore.YELLOW} Associated file label: {associated_file_label} {Style.RESET_ALL}\")\n            block_end = line_number\n\n            results.append({\n                \"block_content\": block_content,\n                \"associated_file_name\": associated_file_name,\n                \"associated_file_label\": associated_file_label,\n                \"modified_lines_within_block\": modified_lines_within_blocks\n            })\n\n            logging.info(f\"{Fore.YELLOW} Block content: \\n{block_content} {Style.RESET_ALL}\")\n            logging.info(f\"{Fore.YELLOW} Block end found at line: {block_end} {Style.RESET_ALL}\")\n            in_block = False\n            block_content = \"\"\n            modified_lines_within_blocks = []\n        elif in_block:\n            block_content += line\n            if line.strip() in modified_lines_set:\n                modified_lines_within_blocks.append(line.strip())\n\n    return results\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.scan_files","title":"<code>scan_files(project_path=dir_path_mock_project)</code>","text":"<p>Scan the repository for modified Python files and return the results in a dictionary.</p> Example <p>file1.py:</p> <pre><code>#IFFT.If\n\n    + line1\n\n    + line2\n\n    + line3\n#IFFT.Then(\"foo_file.py\", \"foo_label\")\n</code></pre> <p>file2.py:</p> <pre><code>#IFFT.If\n\n    + line4\n\n    + line5\n\n    + line6\n#IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n</code></pre> <p>scan_files(project_path)</p> <pre><code>{'file1.py': [{'block_content': '...',\n               'associated_file_name': 'foo_file.py',\n               'associated_file_label': 'foo_label',\n               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n    'file2.py': [{'block_content': '...',\n                'associated_file_name': 'foo_file2.py',\n               'associated_file_label': 'foo_label2',\n               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>A string corresponding to the project path.</p> <code>dir_path_mock_project</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of results.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def scan_files(project_path: str = dir_path_mock_project) -&gt; dict:\n    \"\"\"\n        Scan the repository for modified Python files and return the results in a dictionary.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                #IFFT.If\\n\n                    + line1\\n\n                    + line2\\n\n                    + line3\n                #IFFT.Then(\"foo_file.py\", \"foo_label\")\n            &gt;&gt;&gt;file2.py:\\n\n                #IFFT.If\\n\n                    + line4\\n\n                    + line5\\n\n                    + line6\n                #IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n\n            &gt;&gt;&gt;scan_files(project_path)\\n\n                {'file1.py': [{'block_content': '...',\n                               'associated_file_name': 'foo_file.py',\n                               'associated_file_label': 'foo_label',\n                               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n                    'file2.py': [{'block_content': '...',\n                                'associated_file_name': 'foo_file2.py',\n                               'associated_file_label': 'foo_label2',\n                               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n\n        Args:\n            project_path (str): A string corresponding to the project path.\n\n        Returns:\n            dict: A dictionary of results.\n\n    \"\"\"\n\n    results_dict = {}\n    try:\n        repo = Repo(project_path)\n    except NoSuchPathError:\n        logging.error(f\"{Fore.RED} The path '{project_path}' does not exist. {Style.RESET_ALL}\")\n        return results_dict\n    except InvalidGitRepositoryError:\n        logging.error(f\"{Fore.RED} The path '{project_path}' is not a valid Git repository. {Style.RESET_ALL}\")\n        return results_dict\n    except Exception as e:\n        logging.error(f\"{Fore.RED} Failed to load repository: {e} {Style.RESET_ALL}\")\n        return results_dict\n\n    unstaged_files = [item.a_path for item in repo.index.diff(None)]\n\n    for filename in unstaged_files:\n        if filename.endswith(\".py\"):\n            modified_lines_set = get_modified_lines(repo, filename)\n            results_dict[filename] = scan_file(project_path, filename, modified_lines_set)\n\n    return results_dict\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.validate_associated_file","title":"<code>validate_associated_file(associated_file_name)</code>","text":"<p>Validate if the associated file specified in IFFT block exists.</p> Example <p>validate_associated_file(\"foo_file.py\") True</p> <p>validate_associated_file(\"foo_file2.py\") False</p> <p>Parameters:</p> Name Type Description Default <code>associated_file_name</code> <code>String</code> <p>A string corresponding to the file beeing verified.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>A boolean that indicate whether the specified file is valid or not.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def validate_associated_file(associated_file_name: str) -&gt; bool:\n    \"\"\"\n        Validate if the associated file specified in IFFT block exists.\n\n        Example:\n            &gt;&gt;&gt;validate_associated_file(\"foo_file.py\")\n            True\n\n            &gt;&gt;&gt;validate_associated_file(\"foo_file2.py\")\n            False\n\n        Args:\n            associated_file_name (String): A string corresponding to the file beeing\n                verified.\n\n        Returns:\n            bool: A boolean that indicate whether the specified file is valid or not.\n    \"\"\"\n\n    project_path = os.path.join(dir_path_mock_project)\n    associated_file_name = associated_file_name.replace('\"', '')\n    file_path = os.path.join(project_path, associated_file_name)\n    if not os.path.isfile(file_path):\n        logging.error(f\"{Fore.RED} Associated file: {associated_file_name} not found {Style.RESET_ALL}\")\n        logging.error(f\"{Fore.RED} Associated file path: {file_path} {Style.RESET_ALL}\")\n        return False\n    logging.info(f\"{Fore.YELLOW} Associated file: {associated_file_name} found {Style.RESET_ALL}\")\n    return True\n</code></pre>"}]}