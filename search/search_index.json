{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IFFT","text":"<p>IFFT is a Python linter to help you handle correlated changes across your codebase.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>./ifft.py [dir-name]</code> - Run IFFT tool in [dir_name] project.</li> </ul>"},{"location":"#project-structure","title":"Project structure","text":"<pre><code>  \u251c\u2500\u2500 banner.py\n  \u251c\u2500\u2500 docs\n  \u251c\u2500\u2500 ifft_core\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 ifft_parser.py # File with tool helper methods\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n  \u251c\u2500\u2500 ifft.py # Main file that triggers the tool\n  \u251c\u2500\u2500 mkdocs.yml\n  \u251c\u2500\u2500 mock_project # Mock project to test the tool\n  \u251c\u2500\u2500 README.md\n  \u251c\u2500\u2500 requirements.txt\n  \u251c\u2500\u2500 site # Documentation\n  \u251c\u2500\u2500 surfaces\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 library\n  \u2502\u00a0\u00a0     \u2514\u2500\u2500 filler_file\n  \u2514\u2500\u2500 tests\n      \u251c\u2500\u2500 filler_file\n      \u2514\u2500\u2500 test_ifft_core.py\n</code></pre>"},{"location":"#reccomended-project-structure","title":"Reccomended project structure","text":"<pre><code>  \u2500\u2500 IFFT \n      \u251c\u2500\u2500 ifft_core \n      \u00a0 \u00a0 \u2514\u2500\u2500 ... \n      \u251c\u2500\u2500 ... \n      \u251c\u2500\u2500 ifft.py\n      \u2514\u2500\u2500 your_project \n</code></pre>"},{"location":"block_manager/","title":"Block Manager Class","text":"<p>This page contains information about the BlockManger module methods. Here you can find  detailed information about methods of this module.</p>"},{"location":"block_manager/#block_manager.block_manager_class.BlockManager","title":"<code>BlockManager</code>","text":"Source code in <code>block_manager/block_manager_class.py</code> <pre><code>class BlockManager:\n    def __init__(self, storage_dir=\"block_metadata\", show_active_blocks=False):\n       self.storage_dir = storage_dir\n       self.show_active_blocks = show_active_blocks\n       self.block_data = {}\n\n       # Load metadata into block_data\n       self._load_metadata()\n\n       if self.show_active_blocks:\n           self._display_active_blocks()\n\n    def _load_metadata(self):\n        \"\"\"Load all metadata from the block_metadata directory.\"\"\"\n        if not os.path.exists(self.storage_dir):\n            logging.warning(f\"Metadata directory '{self.storage_dir}' does not exist.\")\n            return\n\n        for metadata_file in os.listdir(self.storage_dir):\n            if metadata_file.endswith(\".json\"):\n                file_path = os.path.join(self.storage_dir, metadata_file)\n                try:\n                    with open(file_path, \"r\") as f:\n                        file_data = json.load(f)\n                        self.block_data[metadata_file] = file_data\n                except json.JSONDecodeError:\n                    logging.error(f\"[ERROR] Invalid JSON in {file_path}. Skipping this file.\")\n                except Exception as e:\n                    logging.error(f\"[ERROR] Could not load metadata from {file_path}: {e}\")\n\n\n    def _display_active_blocks(self):\n        \"\"\"Display active blocks (for visualization purposes).\"\"\"\n        if not self.block_data:\n            print(f\"{Fore.YELLOW}No active blocks found.{Style.RESET_ALL}\")\n            return\n\n        print(f\"{Fore.GREEN}Active Blocks:{Style.RESET_ALL}\")\n        for file_name, blocks in self.block_data.items():\n            print(f\"File: {file_name}\")\n            for block in blocks:\n                print(f\"  Block Label: {block['associated_file_label']}\")\n                print(f\"  Block Start: {block['block_start']}\")\n                print(f\"  Block End: {block['block_end']}\")\n\n\n    def save_metadata(self):\n        with open(self.storage_file, \"w\") as f:\n            json.dump(self.block_data, f, indent=4)\n\n    def get_block_count(self):\n        \"\"\"Count the total number of active IFFT blocks in the project.\"\"\"\n        total_blocks = 0\n        for file, blocks in self.block_data.items():\n            # Counting only blocks with associated_file_name and associated_file_label\n            if (blocks[0]['associated_file_name'] == \"\" or blocks[0]['associated_file_label'] == \"\"):\n                logging.warning(f\"{Fore.YELLOW} A block in file '{file}' does not have 'associated_file_name' or 'associated_file_label'. Skipping it.{Style.RESET_ALL}\")\n                continue\n\n            total_blocks += len(blocks)\n        print(f\"{Fore.GREEN}Total active IFFT blocks in the project: {total_blocks}\")\n        return total_blocks\n\n    def extract_blocks(self, file_name, blocks):\n        \"\"\"\n        Extract IFFT blocks from a file and store their metadata in the block_metadata directory.\n        The original file content is not modified.\n\n        Args:\n            file_name (str): The name of the file to extract blocks from.\n            blocks (list): A list of block information (start, end, content, etc.) for the file.\n        \"\"\"\n        logging.info(f\"Extracting IFFT blocks for {file_name}...\")\n        file_prefix = file_name.split(\"/\")[-1].split(\".\")[0]\n\n        # Ensure the block_metadata directory exists\n        metadata_dir = os.path.join(get_project_root(), \"..\", \"block_metadata\")\n        os.makedirs(metadata_dir, exist_ok=True)\n\n        # Construct the metadata file path\n        metadata_file_path = os.path.join(metadata_dir, f\"{file_prefix}.json\")\n\n        # Prepare metadata to store\n        metadata = []\n        for block in blocks:\n            metadata.append({\n                \"block_start\": block.block_start,\n                \"block_end\": block.block_end,\n                \"block_content\": block.block_content,\n                \"associated_file_name\": block.associated_file_name,\n                \"associated_file_label\": block.associated_file_label\n            })\n\n        # Write metadata to the JSON file\n        with open(metadata_file_path, \"w\") as f:\n            json.dump(metadata, f, indent=4)\n\n        logging.info(f\"Metadata for {file_name} stored in {metadata_file_path}.\")\n\n\n\n    def remove_ifft_trace(self, file_name):\n        \"\"\"\n        Remove IFFT annotations from the file and store metadata in the block_metadata directory.\n        \"\"\"\n        # getting only the filename without the extension\n        # from a pattern like this: /home/thiagosan/\u00c1rea de Trabalho/IFFT/block_manager/block_manager_class.py\n        file_prefix = file_name.split(\"/\")[-1].split(\".\")[0]\n\n        script_file_name = file_prefix + \".py\"\n        metadata_file_name = file_prefix + \".json\"\n\n        logging.info(f\"Removing IFFT blocks from {script_file_name}\")\n        source_file_path = resolve_path(script_file_name)\n\n        if not os.path.exists(source_file_path):\n            logging.error(f\"Source file {script_file_name} not found.\")\n            return\n\n        metadata_path = os.path.join(self.storage_dir, f\"{file_prefix}.json\")\n        metadata = []\n\n        with open(source_file_path, \"r\") as source_file:\n            lines = source_file.readlines()\n\n        # Scan the file and extract metadata for IFFT blocks\n        in_block = False\n        block_content = \"\"\n        block_start = None\n        block_end = None\n        associated_file_name = \"\"\n        associated_file_label = \"\"\n\n        for line_number, line in enumerate(lines):\n            if line.strip().startswith(\"#IFFT.If\"):\n                in_block = True\n                block_start = line_number + 1  # 1-based index\n                block_content += line\n\n            elif line.strip().startswith(\"#IFFT.Then\"):\n                if in_block:\n                    block_end = line_number + 1  # 1-based index\n                    block_content += line\n                    # Extract associated file and label\n                    parts = re.search(r\"#IFFT.Then\\(\\\"(.*?)\\\", \\\"(.*?)\\\"\\)\", line)\n                    if parts:\n                        associated_file_name = parts.group(1)\n                        associated_file_label = parts.group(2)\n\n                    # Store metadata\n                    metadata.append({\n                        \"block_start\": block_start,\n                        \"block_end\": block_end,\n                        \"block_content\": block_content,\n                        \"associated_file_name\": associated_file_name,\n                        \"associated_file_label\": associated_file_label\n                    })\n\n                    # Reset block\n                    in_block = False\n                    block_content = \"\"\n\n            elif in_block:\n                block_content += line\n\n        # Write metadata to file\n        os.makedirs(self.storage_dir, exist_ok=True)\n        with open(metadata_path, \"w\") as metadata_file:\n            json.dump(metadata, metadata_file, indent=4)\n\n        print(f\"{Fore.YELLOW}[INFO] Metadata written to {metadata_path}\")\n\n        # Remove IFFT annotations from the source file\n        lines = [\n            line for line in lines\n            if not line.strip().startswith(\"#IFFT.If\") and not line.strip().startswith(\"#IFFT.Then\")\n        ]\n\n        with open(source_file_path, \"w\") as source_file:\n            source_file.writelines(lines)\n\n        print(f\"{Fore.YELLOW}[INFO] Removed IFFT blocks from {script_file_name}.\")\n\n\n    def restore_ifft_blocks(self, file_name_prefix):\n        \"\"\"\n        Restore IFFT annotations and metadata from the JSON file to the original code.\n        Handles edge cases where blocks span the last line of the file.\n        \"\"\"\n\n        file_prefix = file_name_prefix.split(\"/\")[-1].split(\".\")[0]\n        print(f\"{Fore.YELLOW}[INFO] Restoring IFFT blocks for file: {Style.RESET_ALL}\", file_prefix)\n\n        # Construct the path to the metadata file\n        metadata_path = os.path.join(\"block_metadata\", f\"{file_prefix}.json\")\n        logging.info(f\"Metadata path: {metadata_path}\")\n\n        if not os.path.exists(metadata_path):\n            print(f\"{Fore.RED}[ERROR] Metadata file for {file_prefix} not found.\")\n            return\n\n        # Load metadata\n        with open(metadata_path, \"r\") as f:\n            metadata = json.load(f)\n\n        filename = f\"{file_prefix}.py\"\n        # Read the target file\n        target_file_path = os.path.join(get_project_root(), filename)\n        if not os.path.exists(target_file_path):\n            print(f\"{Fore.RED}[ERROR] Target file {filename} not found.{Style.RESET_ALL}\")\n            return\n\n        with open(target_file_path, \"r\") as f:\n            lines = f.readlines()\n\n        # Restore each block in reverse order\n        for block in sorted(metadata, key=lambda b: -b[\"block_start\"]):\n            block_start = block[\"block_start\"] - 1\n            block_end = block[\"block_end\"] - 1\n\n            # Insert the opening marker if it does not already exist\n            if block_start &lt; len(lines) and not lines[block_start].strip().startswith(\"#IFFT.If\"):\n                lines.insert(block_start, f\"#IFFT.If({block['associated_file_label']})\\n\")\n\n            # Insert the closing marker if it does not already exist\n            if block_end &gt;= len(lines):  # Handle edge case for last line\n                lines.append(f\"#IFFT.Then(\\\"{block['associated_file_name']}\\\", \\\"{block['associated_file_label']}\\\")\\n\")\n            elif not any(line.strip().startswith(\"#IFFT.Then\") and block[\"associated_file_label\"] in line for line in lines[block_end:]):\n                lines.insert(block_end + 1, f\"#IFFT.Then(\\\"{block['associated_file_name']}\\\", \\\"{block['associated_file_label']}\\\")\\n\")\n\n        # Write back to the target file\n        with open(target_file_path, \"w\") as f:\n            f.writelines(lines)\n\n        print(f\"{Fore.YELLOW}[INFO] Successfully restored IFFT blocks to {filename}\")\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.BlockManager.extract_blocks","title":"<code>extract_blocks(file_name, blocks)</code>","text":"<p>Extract IFFT blocks from a file and store their metadata in the block_metadata directory. The original file content is not modified.</p> <p>Parameters:</p> Name Type Description Default <code>file_name</code> <code>str</code> <p>The name of the file to extract blocks from.</p> required <code>blocks</code> <code>list</code> <p>A list of block information (start, end, content, etc.) for the file.</p> required Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def extract_blocks(self, file_name, blocks):\n    \"\"\"\n    Extract IFFT blocks from a file and store their metadata in the block_metadata directory.\n    The original file content is not modified.\n\n    Args:\n        file_name (str): The name of the file to extract blocks from.\n        blocks (list): A list of block information (start, end, content, etc.) for the file.\n    \"\"\"\n    logging.info(f\"Extracting IFFT blocks for {file_name}...\")\n    file_prefix = file_name.split(\"/\")[-1].split(\".\")[0]\n\n    # Ensure the block_metadata directory exists\n    metadata_dir = os.path.join(get_project_root(), \"..\", \"block_metadata\")\n    os.makedirs(metadata_dir, exist_ok=True)\n\n    # Construct the metadata file path\n    metadata_file_path = os.path.join(metadata_dir, f\"{file_prefix}.json\")\n\n    # Prepare metadata to store\n    metadata = []\n    for block in blocks:\n        metadata.append({\n            \"block_start\": block.block_start,\n            \"block_end\": block.block_end,\n            \"block_content\": block.block_content,\n            \"associated_file_name\": block.associated_file_name,\n            \"associated_file_label\": block.associated_file_label\n        })\n\n    # Write metadata to the JSON file\n    with open(metadata_file_path, \"w\") as f:\n        json.dump(metadata, f, indent=4)\n\n    logging.info(f\"Metadata for {file_name} stored in {metadata_file_path}.\")\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.BlockManager.get_block_count","title":"<code>get_block_count()</code>","text":"<p>Count the total number of active IFFT blocks in the project.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def get_block_count(self):\n    \"\"\"Count the total number of active IFFT blocks in the project.\"\"\"\n    total_blocks = 0\n    for file, blocks in self.block_data.items():\n        # Counting only blocks with associated_file_name and associated_file_label\n        if (blocks[0]['associated_file_name'] == \"\" or blocks[0]['associated_file_label'] == \"\"):\n            logging.warning(f\"{Fore.YELLOW} A block in file '{file}' does not have 'associated_file_name' or 'associated_file_label'. Skipping it.{Style.RESET_ALL}\")\n            continue\n\n        total_blocks += len(blocks)\n    print(f\"{Fore.GREEN}Total active IFFT blocks in the project: {total_blocks}\")\n    return total_blocks\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.BlockManager.remove_ifft_trace","title":"<code>remove_ifft_trace(file_name)</code>","text":"<p>Remove IFFT annotations from the file and store metadata in the block_metadata directory.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def remove_ifft_trace(self, file_name):\n    \"\"\"\n    Remove IFFT annotations from the file and store metadata in the block_metadata directory.\n    \"\"\"\n    # getting only the filename without the extension\n    # from a pattern like this: /home/thiagosan/\u00c1rea de Trabalho/IFFT/block_manager/block_manager_class.py\n    file_prefix = file_name.split(\"/\")[-1].split(\".\")[0]\n\n    script_file_name = file_prefix + \".py\"\n    metadata_file_name = file_prefix + \".json\"\n\n    logging.info(f\"Removing IFFT blocks from {script_file_name}\")\n    source_file_path = resolve_path(script_file_name)\n\n    if not os.path.exists(source_file_path):\n        logging.error(f\"Source file {script_file_name} not found.\")\n        return\n\n    metadata_path = os.path.join(self.storage_dir, f\"{file_prefix}.json\")\n    metadata = []\n\n    with open(source_file_path, \"r\") as source_file:\n        lines = source_file.readlines()\n\n    # Scan the file and extract metadata for IFFT blocks\n    in_block = False\n    block_content = \"\"\n    block_start = None\n    block_end = None\n    associated_file_name = \"\"\n    associated_file_label = \"\"\n\n    for line_number, line in enumerate(lines):\n        if line.strip().startswith(\"#IFFT.If\"):\n            in_block = True\n            block_start = line_number + 1  # 1-based index\n            block_content += line\n\n        elif line.strip().startswith(\"#IFFT.Then\"):\n            if in_block:\n                block_end = line_number + 1  # 1-based index\n                block_content += line\n                # Extract associated file and label\n                parts = re.search(r\"#IFFT.Then\\(\\\"(.*?)\\\", \\\"(.*?)\\\"\\)\", line)\n                if parts:\n                    associated_file_name = parts.group(1)\n                    associated_file_label = parts.group(2)\n\n                # Store metadata\n                metadata.append({\n                    \"block_start\": block_start,\n                    \"block_end\": block_end,\n                    \"block_content\": block_content,\n                    \"associated_file_name\": associated_file_name,\n                    \"associated_file_label\": associated_file_label\n                })\n\n                # Reset block\n                in_block = False\n                block_content = \"\"\n\n        elif in_block:\n            block_content += line\n\n    # Write metadata to file\n    os.makedirs(self.storage_dir, exist_ok=True)\n    with open(metadata_path, \"w\") as metadata_file:\n        json.dump(metadata, metadata_file, indent=4)\n\n    print(f\"{Fore.YELLOW}[INFO] Metadata written to {metadata_path}\")\n\n    # Remove IFFT annotations from the source file\n    lines = [\n        line for line in lines\n        if not line.strip().startswith(\"#IFFT.If\") and not line.strip().startswith(\"#IFFT.Then\")\n    ]\n\n    with open(source_file_path, \"w\") as source_file:\n        source_file.writelines(lines)\n\n    print(f\"{Fore.YELLOW}[INFO] Removed IFFT blocks from {script_file_name}.\")\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.BlockManager.restore_ifft_blocks","title":"<code>restore_ifft_blocks(file_name_prefix)</code>","text":"<p>Restore IFFT annotations and metadata from the JSON file to the original code. Handles edge cases where blocks span the last line of the file.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def restore_ifft_blocks(self, file_name_prefix):\n    \"\"\"\n    Restore IFFT annotations and metadata from the JSON file to the original code.\n    Handles edge cases where blocks span the last line of the file.\n    \"\"\"\n\n    file_prefix = file_name_prefix.split(\"/\")[-1].split(\".\")[0]\n    print(f\"{Fore.YELLOW}[INFO] Restoring IFFT blocks for file: {Style.RESET_ALL}\", file_prefix)\n\n    # Construct the path to the metadata file\n    metadata_path = os.path.join(\"block_metadata\", f\"{file_prefix}.json\")\n    logging.info(f\"Metadata path: {metadata_path}\")\n\n    if not os.path.exists(metadata_path):\n        print(f\"{Fore.RED}[ERROR] Metadata file for {file_prefix} not found.\")\n        return\n\n    # Load metadata\n    with open(metadata_path, \"r\") as f:\n        metadata = json.load(f)\n\n    filename = f\"{file_prefix}.py\"\n    # Read the target file\n    target_file_path = os.path.join(get_project_root(), filename)\n    if not os.path.exists(target_file_path):\n        print(f\"{Fore.RED}[ERROR] Target file {filename} not found.{Style.RESET_ALL}\")\n        return\n\n    with open(target_file_path, \"r\") as f:\n        lines = f.readlines()\n\n    # Restore each block in reverse order\n    for block in sorted(metadata, key=lambda b: -b[\"block_start\"]):\n        block_start = block[\"block_start\"] - 1\n        block_end = block[\"block_end\"] - 1\n\n        # Insert the opening marker if it does not already exist\n        if block_start &lt; len(lines) and not lines[block_start].strip().startswith(\"#IFFT.If\"):\n            lines.insert(block_start, f\"#IFFT.If({block['associated_file_label']})\\n\")\n\n        # Insert the closing marker if it does not already exist\n        if block_end &gt;= len(lines):  # Handle edge case for last line\n            lines.append(f\"#IFFT.Then(\\\"{block['associated_file_name']}\\\", \\\"{block['associated_file_label']}\\\")\\n\")\n        elif not any(line.strip().startswith(\"#IFFT.Then\") and block[\"associated_file_label\"] in line for line in lines[block_end:]):\n            lines.insert(block_end + 1, f\"#IFFT.Then(\\\"{block['associated_file_name']}\\\", \\\"{block['associated_file_label']}\\\")\\n\")\n\n    # Write back to the target file\n    with open(target_file_path, \"w\") as f:\n        f.writelines(lines)\n\n    print(f\"{Fore.YELLOW}[INFO] Successfully restored IFFT blocks to {filename}\")\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.get_project_root","title":"<code>get_project_root()</code>","text":"<p>Retrieve the project root directory from the configuration.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def get_project_root():\n    \"\"\"Retrieve the project root directory from the configuration.\"\"\"\n    config = load_config()\n    project_root = config.get(\"project_root\", \"mock_project\")\n    return os.path.abspath(project_root)  # Ensure it's an absolute path\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.list_python_files","title":"<code>list_python_files(project_root=None, metadata_dir='block_metadata')</code>","text":"<p>List all tracked Python files in the user-specified project. First checks the block_metadata directory, and falls back to scanning the project root.</p> <p>Parameters:</p> Name Type Description Default <code>project_root</code> <code>str</code> <p>Root path of the project (default: None).</p> <code>None</code> <code>metadata_dir</code> <code>str</code> <p>Directory where metadata is stored.</p> <code>'block_metadata'</code> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: List of Python file paths.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def list_python_files(project_root=None, metadata_dir=\"block_metadata\") -&gt; List[str]:\n    \"\"\"\n    List all tracked Python files in the user-specified project.\n    First checks the block_metadata directory, and falls back to scanning the project root.\n\n    Args:\n        project_root (str): Root path of the project (default: None).\n        metadata_dir (str): Directory where metadata is stored.\n\n    Returns:\n        List[str]: List of Python file paths.\n    \"\"\"\n    if not project_root:\n        project_root = get_project_root()\n\n    python_files = []\n\n    # Option 1: Use metadata directory to find tracked files\n    metadata_path = os.path.join(project_root, metadata_dir)\n    if os.path.exists(metadata_path):\n        for metadata_file in os.listdir(metadata_path):\n            if metadata_file.endswith(\".json\"):\n                python_files.append(os.path.join(project_root, metadata_file.replace(\".json\", \".py\")))\n\n    # Option 2: Fallback to scanning the project root\n    if not python_files:\n        for root, _, files in os.walk(project_root):\n            for file in files:\n                if file.endswith(\".py\"):\n                    python_files.append(os.path.join(root, file))\n\n    return python_files\n</code></pre>"},{"location":"block_manager/#block_manager.block_manager_class.load_config","title":"<code>load_config()</code>","text":"<p>Load the IFFT configuration file.</p> Source code in <code>block_manager/block_manager_class.py</code> <pre><code>def load_config():\n    \"\"\"Load the IFFT configuration file.\"\"\"\n    config_path = os.path.join(os.path.dirname(__file__), 'ifft_config.json')\n    if os.path.exists(config_path):\n        with open(config_path) as config_file:\n            return json.load(config_file)\n    return {}\n</code></pre>"},{"location":"dependencies/","title":"Installing Project Dependencies","text":"<p>To set up the project environment, follow these steps:</p>"},{"location":"dependencies/#step-1-create-a-virtual-environment-optional-but-recommended","title":"Step 1: Create a Virtual Environment (Optional but Recommended)","text":"<p>It is recommended to create a virtual environment to keep project dependencies isolated.</p> <p>Run the following command to create and activate a virtual environment:</p> <pre><code># Create virtual environment\npython3 -m venv venv\n\n# Activate virtual environment (Linux/MacOS)\nsource venv/bin/activate\n\n# Activate virtual environment (Windows)\nvenv\\Scripts\\activate\n</code></pre>"},{"location":"dependencies/#step-2-install-dependencies","title":"Step 2: Install Dependencies","text":"<p>Use the <code>requirements.txt</code> file to install all necessary packages:</p> <pre><code># Installing dependencies \npip3 install -r requirements.txt\n</code></pre>"},{"location":"dependencies/#step-3-verify-installation","title":"Step 3: Verify Installation","text":"<p>Check if all dependencies were installed correctly:</p> <pre><code># Checking \npip3 check \n</code></pre>"},{"location":"helpers/","title":"Helpers","text":"<p>This page contains information about helper functions used in this project.</p>"},{"location":"helpers/#helpers.helpers.get_project_root","title":"<code>get_project_root()</code>","text":"<p>Retrieve the project root path from the configuration file.</p> Source code in <code>helpers/helpers.py</code> <pre><code>def get_project_root():\n    \"\"\"Retrieve the project root path from the configuration file.\"\"\"\n    config_path = os.path.join(os.path.dirname(__file__), \"..\", \"ifft_config.json\")\n    with open(config_path, \"r\") as config_file:\n        config = json.load(config_file)\n    return config.get(\"project_root\", os.getcwd())\n</code></pre>"},{"location":"helpers/#helpers.helpers.resolve_path","title":"<code>resolve_path(relative_path)</code>","text":"<p>Resolve a relative path to the project root.</p> Source code in <code>helpers/helpers.py</code> <pre><code>def resolve_path(relative_path):\n    \"\"\"Resolve a relative path to the project root.\"\"\"\n    project_root = get_project_root()\n    return os.path.join(project_root, relative_path)\n</code></pre>"},{"location":"reference/","title":"Parser","text":"<p>This part of the project documentation focuses on an information-oriented approach. You can find all helper methods defined by the \"ifft_core\" module here. You'll find detailed information about the method signatures, return types, exceptions, and examples.</p> <p>The module contains the following functions:</p> <ul> <li><code>get_modified_lines(repo, filename) - Get a set of modified lines for the given filename.</code></li> <li><code>scan_file(project_path, filename, modified_lines_set) - Scan the file for IFFT blocks and return the results.</code></li> <li><code>scan_files(project_path, dir_path_mock_project) - Scan the repository for modified Python files and return the results in a dictionary.</code></li> <li><code>validate_associated_file(associated_file_name)</code> - Validade if the associated file specified in IFFT block exists.</li> </ul>"},{"location":"reference/#note-for-the-examples-in-this-documentation-the-plus-sign-indicates-a-modified-line","title":"Note: For the examples in this documentation, the plus sign (+) indicates a modified line.","text":""},{"location":"reference/#ifft_core.ifft_parser.get_modified_lines","title":"<code>get_modified_lines(repo, filename, auto_mode)</code>","text":"<p>Get a set of modified lines for the given filename.</p> Example <p>file1.py:</p> <pre><code>+ line1\n\n+ line2\n\n+ line3\n</code></pre> <p>get_modified_lines(repo, file1.py)</p> <p>{'line1', 'line2', 'line3'}</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>A string corresponding to the repository.</p> required <code>filename</code> <code>str</code> <p>A string corresponding to the filename.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of modified lines.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def get_modified_lines(repo: str, filename: str, auto_mode: argparse.Namespace) -&gt; set:\n    \"\"\"\n        Get a set of modified lines for the given filename.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                + line1\\n\n                + line2\\n\n                + line3\n\n            &gt;&gt;&gt;get_modified_lines(repo, file1.py)\\n\n            {'line1', 'line2', 'line3'}\n\n        Args:\n            repo (str): A string corresponding to the repository.\n            filename (str): A string corresponding to the filename.\n\n        Returns:\n            set: A set of modified lines.\n\n    \"\"\"\n    modified_lines = set()\n    diff_text = \"\"\n\n    if not auto_mode:\n        diff_text = repo.git.diff(None, filename)\n\n    else:\n        diff_text = repo.git.diff('HEAD', filename)\n\n    logging.debug(f\"{Fore.BLUE} DIFF TEXT: {diff_text} {Style.RESET_ALL}\")\n    logging.debug(f\"{Fore.BLUE} REPO: {repo} {Style.RESET_ALL}\")\n    logging.debug(f\"{Fore.BLUE} FILENAME: {filename} {Style.RESET_ALL}\")\n\n    diff_lines = diff_text.split('\\n')\n    line_number = 0\n\n    for line in diff_lines:\n        if line.startswith('@@'):\n            line_number = int(line.split()[2].split(',')[0].replace('+', ''))\n        elif line.startswith('+') and not line.startswith('+++'):\n            modified_lines.add((line_number, line[1:].strip()))\n            line_number += 1\n        elif line.startswith(' '):\n            line_number += 1\n\n    logging.info(f\"{Fore.YELLOW} Modified lines: {modified_lines} {Style.RESET_ALL}\")\n    return modified_lines\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.save_results_to_file","title":"<code>save_results_to_file(results, output_file='ifft_results.json')</code>","text":"<p>Save the scan results to a JSON file for use in the UI.</p> <p>Parameters:</p> Name Type Description Default <code>results</code> <code>dict</code> <p>The dictionary of scan results.</p> required <code>output_file</code> <code>str</code> <p>The file path to save the results.</p> <code>'ifft_results.json'</code> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def save_results_to_file(results, output_file=\"ifft_results.json\"):\n    \"\"\"\n    Save the scan results to a JSON file for use in the UI.\n\n    Args:\n        results (dict): The dictionary of scan results.\n        output_file (str): The file path to save the results.\n    \"\"\"\n    def serialize_blocks(blocks):\n        \"\"\"Convert IFFTBlock objects to dictionaries.\"\"\"\n        serialized = []\n        for block in blocks:\n            if hasattr(block, '__dict__'):\n                serialized.append(block.__dict__)  # Use __dict__ for custom objects\n            else:\n                serialized.append(block)  # Assume it's already a serializable type\n        return serialized\n\n    serializable_results = {file: serialize_blocks(blocks) for file, blocks in results.items()}\n\n    try:\n        with open(output_file, \"w\") as f:\n            json.dump(serializable_results, f, indent=4)\n        logging.info(f\"{Fore.YELLOW} Results successfully saved to {output_file}{Style.RESET_ALL}\") \n    except Exception as e:\n        logging.error(f\"{Fore.RED} Failed to save results: {e}\") \n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.scan_files","title":"<code>scan_files(project_path=dir_path_mock_project, auto_mode=None)</code>","text":"<p>Scan the repository for modified Python files and return the results in a dictionary.</p> Example <p>file1.py:</p> <pre><code>#IFFT.If\n\n    + line1\n\n    + line2\n\n    + line3\n#IFFT.Then(\"foo_file.py\", \"foo_label\")\n</code></pre> <p>file2.py:</p> <pre><code>#IFFT.If\n\n    + line4\n\n    + line5\n\n    + line6\n#IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n</code></pre> <p>scan_files(project_path)</p> <pre><code>{'file1.py': [{'block_content': '...',\n               'associated_file_name': 'foo_file.py',\n               'associated_file_label': 'foo_label',\n               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n    'file2.py': [{'block_content': '...',\n                'associated_file_name': 'foo_file2.py',\n               'associated_file_label': 'foo_label2',\n               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>A string corresponding to the project path.</p> <code>dir_path_mock_project</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of results.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def scan_files(project_path: str = dir_path_mock_project, auto_mode: argparse.Namespace = None) -&gt; dict:\n    \"\"\"\n        Scan the repository for modified Python files and return the results in a dictionary.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                #IFFT.If\\n\n                    + line1\\n\n                    + line2\\n\n                    + line3\n                #IFFT.Then(\"foo_file.py\", \"foo_label\")\n            &gt;&gt;&gt;file2.py:\\n\n                #IFFT.If\\n\n                    + line4\\n\n                    + line5\\n\n                    + line6\n                #IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n\n            &gt;&gt;&gt;scan_files(project_path)\\n\n                {'file1.py': [{'block_content': '...',\n                               'associated_file_name': 'foo_file.py',\n                               'associated_file_label': 'foo_label',\n                               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n                    'file2.py': [{'block_content': '...',\n                                'associated_file_name': 'foo_file2.py',\n                               'associated_file_label': 'foo_label2',\n                               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n\n        Args:\n            project_path (str): A string corresponding to the project path.\n\n        Returns:\n            dict: A dictionary of results.\n\n    \"\"\"\n\n    results_dict = {}\n    try:\n        repo = Repo(project_path)\n        logging.info(f\"{Fore.YELLOW}Scanning Git repository: {project_path}{Style.RESET_ALL}\")\n    except NoSuchPathError:\n        logging.error(f\"{Fore.RED}The path '{project_path}' does not exist.{Style.RESET_ALL}\")\n        return results_dict\n    except InvalidGitRepositoryError:\n        logging.warning(f\"{Fore.ORANGE}The path '{project_path}' is not a valid Git repository. Skipping Git-specific checks.{Style.RESET_ALL}\")\n        # Optionally return or skip additional scanning logic for non-Git directories\n        return results_dict\n    except Exception as e:\n        logging.error(f\"{Fore.RED}An unexpected error occurred: {e}{Style.RESET_ALL}\")\n        return results_dict\n\n    modified_files = []\n    if not auto_mode:\n        modified_files = [item.a_path for item in repo.index.diff(None)]\n    else:\n        result = subprocess.run(['git', 'diff', '--cached', '--name-only', '--diff-filter=ACM'], capture_output=True, text=True)\n        modified_files = result.stdout.splitlines()\n\n    logging.info(f\"{Fore.YELLOW}Modified files found: {modified_files}{Style.RESET_ALL}\")\n\n    for filename in modified_files:\n        if filename.endswith(\".py\"):\n            logging.info(f\"{Fore.YELLOW}Scanning file: {filename}{Style.RESET_ALL}\")\n            modified_lines_set = get_modified_lines(repo, filename, auto_mode)\n            file_results = scan_file(project_path, filename, modified_lines_set)\n            if file_results:\n                results_dict[filename] = file_results\n\n    return results_dict\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.validate_associated_file","title":"<code>validate_associated_file(associated_file_name)</code>","text":"<p>Validate if the associated file specified in IFFT block exists.</p> Example <p>validate_associated_file(\"foo_file.py\") True</p> <p>validate_associated_file(\"foo_file2.py\") False</p> <p>Parameters:</p> Name Type Description Default <code>associated_file_name</code> <code>String</code> <p>A string corresponding to the file beeing verified.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>A boolean that indicate whether the specified file is valid or not.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def validate_associated_file(associated_file_name: str) -&gt; bool:\n    \"\"\"\n        Validate if the associated file specified in IFFT block exists.\n\n        Example:\n            &gt;&gt;&gt;validate_associated_file(\"foo_file.py\")\n            True\n\n            &gt;&gt;&gt;validate_associated_file(\"foo_file2.py\")\n            False\n\n        Args:\n            associated_file_name (String): A string corresponding to the file beeing\n                verified.\n\n        Returns:\n            bool: A boolean that indicate whether the specified file is valid or not.\n    \"\"\"\n\n    project_path = os.path.join(dir_path_mock_project)\n    associated_file_name = associated_file_name.replace('\"', '')\n    file_path = os.path.join(project_path, associated_file_name)\n    if not os.path.isfile(file_path):\n        logging.error(f\"{Fore.RED} Associated file: {associated_file_name} not found {Style.RESET_ALL}\")\n        logging.error(f\"{Fore.RED} Associated file path: {file_path} {Style.RESET_ALL}\")\n        return False\n    logging.info(f\"{Fore.YELLOW} Associated file: {associated_file_name} found {Style.RESET_ALL}\")\n    return True\n</code></pre>"},{"location":"tutorial-example-automode/","title":"Example - Automode","text":"<p>This section of documentaion consists in step-by-step example of the code usage in mock project using automode. The idea here is to give a glimpse of how the tool can be used in a real project.</p> <p>Here is the following <code>mock project</code> structure:</p> <pre><code>../mock_project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 file1.py\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The content of the files are as follows:</p>"},{"location":"tutorial-example-automode/#apppy","title":"app.py","text":"<pre><code>import os\n\nfile_dir = os.path.dirname(__file__)\n\n\n#IFFT.If(foo1 block)\ndef foo1(number1: int, number2: int) -&gt; int:\n    # Adding a change for testing purposes\n    return number1 + number2\n\n# Adding a change for testing purposes\n\ndef foo5(number1: int, number2: int) -&gt; int:\n    return number1 ** number2\n\ndef foo6(number1: int, number2: int) -&gt; int:\n    return number1 % number2\n\ndef foo7(number1: int, number2: int) -&gt; int:\n    return number1 // number2\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\ndef foo2(number1: int, number2: int) -&gt; int:\n    return number1 - number2\n\ndef foo3(number1: int, number2: int) -&gt; int:\n    return number1 * number2\n\ndef foo4(number1: int, number2: int) -&gt; int:\n    return number1 / number2\n\ndef foo8(number1: int, number2: int) -&gt; int:\n    return 2*number1 + number2\n\n# main\n\nprint(foo1(1, 2))\nprint(foo2(1, 2))\nprint(foo3(1, 2))\n\n</code></pre>"},{"location":"tutorial-example-automode/#file1py","title":"file1.py","text":"<pre><code>#IFFT.If This is a test comment\n\nprint('Hello world!')\n\n#IFFT.Then (path_to_associated_file, associated_file_ifft_label)\n</code></pre>"},{"location":"tutorial-example-automode/#step-0-pre-commit-configuration","title":"Step 0: pre-commit configuration","text":"<p>In order to use IFFT in automode all you have to do is create a pre-commit file for your project. The follow is a pre-filled template that should cover the great majority of the use cases:</p> <p>Note1: This script consider the proposed project structure (you can find it in the docs main page). Ih you diverge from that structure, please make sure to do the necessary changes in the script, specially the paths.</p> <p>Note2: You'll be able to find this template file in the project repository with the name <code>pre-commit-template</code>, if you download it, don't forget to change the name before to <code>pre-commit</code>, the file that will be in the hooks config should have the later name.</p> <pre><code>#!/bin/bash\n\n# This is a pre-commit template configuration that can be used for any project with\n# just minor changes\n\nPROJECT_DIR=$(pwd)\n\n# Path to the IFFT script \nIFFT_SCRIPT_PATH=\"../ifft.py\"\n\n# Checking for Python files in staging area\nSTAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\\.py$')\n\n# If we don't have any staged files, the program can end\nif [ -z \"$STAGED_FILES\" ]; then\n    exit 0\nfi\n\n# Now going to the project directory\ncd \"$PROJECT_DIR\"\n\n# Running IFFT script with auto_mode flag and getting the output\nOUTPUT=$(python3 \"$IFFT_SCRIPT_PATH\" --auto 2&gt;&amp;1)\nIFFT_EXIT_CODE=$?\n\n# Show the output\necho \"$OUTPUT\"\n\n# Check IFFT output\n# If auto_mode is beeing used and a change is identified inside a IFFT block\n# the program will ask (before commit - this is the reason why this bash script\n# is for pre-commit hook) if he wants to continue with te commit or abort.\nif [ $IFFT_EXIT_CODE -ne 0 ]; then\n    echo \"IFFT check detected changes in the blocks.\"\n\n    read -p \"Changes detected in IFFT blocks. Do you want to continue with the commit? (y/n): \" CONTINUE_COMMIT &lt; /dev/tty\n\n    if [[ \"$CONTINUE_COMMIT\" != \"y\" &amp;&amp; \"$CONTINUE_COMMIT\" != \"Y\" ]]; then\n        echo \"Commit aborted.\"\n        exit 1\n    fi\nfi\n\n# Succesfull execution\nexit 0\n\n</code></pre> <p>If you project structure is following the recommended pattern (can be found documentation main page), all you have to fill out is the path to ifft script and it's all setup.</p>"},{"location":"tutorial-example-automode/#step-1-checking-if-the-auto-mode-is-enabled","title":"Step 1: Checking if the \"auto-mode\" is enabled","text":"<p>You can run the following command on your terminal or alternatively, you can open it in any text editor.</p> <pre><code>$ cat ifft_config.json\n</code></pre> <p>You should see something like this: </p> <p>This is where IFFT configuration can be changed, as this tutorial aims to show how automode works I will switch it to true.</p>"},{"location":"tutorial-example-automode/#step-2-triggering-the-tool","title":"Step 2: Triggering the tool","text":"<p>The main idea of automode is to run IFFT automatically. More especifically just before the  creation of a commit. In automode IFFT will run every time a new commit is created and will give you one of the two outputs:   - A message saying that none change was found inside a IFFT block.     - Commit is made normally.</p> <ul> <li>A message saying that changes were found inside IFFT blocks and asking you     if you want to continue with the commit anyways or to abort:<ul> <li>If you take (y) as option (anything different of (n or N) actually) the commit action   will happen normally.</li> </ul> </li> </ul> <p>Thats the process in summary. Now, follow the practical examples:</p>"},{"location":"tutorial-example-automode/#step-1-making-a-change-outside-a-ifft-block","title":"Step 1: Making a change outside a IFFT block:","text":"<p>We'll add a new function inside the <code>app.py</code> file, outside any IFFT block. The new function is as follows:</p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\ndef outsideFunction() -&gt; None:\n    print(\"This is a new function added outside of any IFFT block!\")\n\n# main\n\n...\n</code></pre> <p>After the change addition, we have the following as the output for git status command:</p> <pre><code>$ git status \n</code></pre> <p></p> <p>As mentioned before, we need to proceed to do a commit in order to have the tool automatically triggered, this is done as follow:</p> <pre><code>$ git add app.py\n$ git commit -m \"Commit message\"\n</code></pre> <p>As soon as we run the commit command, we should have the feature triggering automatically and, in this case, we should have something like this: </p> <p>Note that the change cannot be found in the debug output, since it is not inside an IFFT block. For this reason the program just show a empty list of modified lines inside IFFT block and says that \"No changes detected in IFFT blocks\". </p> <p>Note 1: You can ignore this .env file for this example. Note 2: Please note that the commit is done normally in this case.</p>"},{"location":"tutorial-example-automode/#step-2-making-a-change-inside-a-ifft-block","title":"Step 2: Making a change inside a IFFT block:","text":"<p>Now, we'll add a new function inside the <code>app.py</code> file, inside the <code>foo1</code> IFFT block. The new function is as follows:</p> <p>Just a reminder before we proceed. In this stage, we have already commited the first change (outside one) so it will not appear in the diff for this section.</p> <p></p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\ndef insideFunction() -&gt; None:\n    print(\"This is a new function added inside of an IFFT block!\")\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\n</code></pre> <p>Again, doing the same process of the last example (git add followed by git commit command) we have the following:</p> <p></p> <p>Note that now the tool detected the change and now recommends the developer to take a look at the associated file <code>file1.py</code> (more specefically in <code>foo1_related_block</code>) to see if any changes are needed.</p> <p>Not only that, now the tool also asks the developer if he wants to go on with his commit or abort the commit. If it's the case where the developer didn't know that those two files are related or forgot about it, normally he will at least check if everything is ok, so he'll probably abort it at first. After take a look in the code and change what is necessary or he came to an conclusion that a change is not necessary, he can go on with the commit.</p>"},{"location":"tutorial-example-automode/#final-message","title":"Final message","text":"<p>Important final note: Please keep in mind that the <code>manual</code> <code>auto</code> mode works differently. The <code>auto</code> mode monitors files in staging area (in other words, after you use a git add command or equivalent), while the <code>manual</code> mode monitors files in unstaged area.</p> <p>This is the end of the tutorial. The tool can be used in a real project to help developers to keep track of the changes and to make sure that the changes are propagated to the associated files. This tutorial isn't a exact one but it should be enough to give a glimpse of how the tool can be used in a real project.</p>"},{"location":"tutorial-example-interface/","title":"Interface Web","text":"<p>This section of documentaion will contain some information regarding IFFT Web Interface. The idea here is to give a general idea of which options are available.</p> <p>Important Note: Use this command to start the IFFT UI version.</p> <pre><code> // Make sure you are inside the IFFT folder\n $ python3 IFFT_WEB/app.py \n</code></pre> <p></p> <p>Here is the list of corrent <code>features</code> supported by the UI version:</p> <pre><code>- Output viewer\n- Graph viewer\n- Settings\n</code></pre> <p>The content of the files are as follows:</p>"},{"location":"tutorial-example-interface/#output-viewer","title":"Output Viewer","text":"<p>This is the page where you can get access to the tool output in a very intuitive and more visual appealing way. You should be able to get the same results as showed in terminal, but with the advantage of have a more scalable way of see the contents.</p> <p></p> <p>Note: The default project is the \"mock_project\", so the [dir_name] parameter was not passed.</p>"},{"location":"tutorial-example-interface/#search-tab","title":"Search Tab","text":"<p>You can use the search tab to filter some files of interest or search for a specific file. This can be very useful when you have a lot of changes inside IFFT blocks in the same change list. </p>"},{"location":"tutorial-example-interface/#modal-viewer","title":"Modal viewer","text":"<p>Instead of just show the newly added or removed content for each file, the actual result is stored inside a modal, for the sake of scalability. You can see the actual result clicking in the <code>View Modified Lines</code> button.. </p>"},{"location":"tutorial-example-interface/#download-metadata","title":"Download Metadata","text":"<p>You can also download the IFFT blocks metadata both by JSON and CSV format. </p>"},{"location":"tutorial-example-interface/#graph-viewer","title":"Graph Viewer","text":"<p>This is the page where you can see the current dependcy relation between IFFT blocks in your change list.</p> <p></p> <p>It's a very handy way to see the dependencies and it is way easier then verify it through the command line. The Graph is very interactive with actions such as: zoom in, zoom out, node dragging and others. Feel free to explore!</p>"},{"location":"tutorial-example-interface/#settings-page","title":"Settings Page","text":"<p>This page allows you to opt-in and out of IFFT features in very easy way. You can safely toggle between the options as it has a build-in validation implemented so no worries of breaking things! After you make any changes, the configuration source will be syncronized with the UI immediately.</p> <p></p>"},{"location":"tutorial-example-manual/","title":"Example - Manual","text":"<p>This section of documentaion consists in step-by-step example of the code usage in mock project using manual mode. The idea here is to give a glimpse of how the tool can be used in a real project.</p> <p>Here is the following <code>mock project</code> structure:</p> <pre><code>../mock_project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 file1.py\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The content of the files are as follows:</p>"},{"location":"tutorial-example-manual/#apppy","title":"app.py","text":"<pre><code>import os\n\nfile_dir = os.path.dirname(__file__)\n\n\n#IFFT.If(foo1 block)\ndef foo1(number1: int, number2: int) -&gt; int:\n    # Adding a change for testing purposes\n    return number1 + number2\n\n# Adding a change for testing purposes\n\ndef foo5(number1: int, number2: int) -&gt; int:\n    return number1 ** number2\n\ndef foo6(number1: int, number2: int) -&gt; int:\n    return number1 % number2\n\ndef foo7(number1: int, number2: int) -&gt; int:\n    return number1 // number2\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\ndef foo2(number1: int, number2: int) -&gt; int:\n    return number1 - number2\n\ndef foo3(number1: int, number2: int) -&gt; int:\n    return number1 * number2\n\ndef foo4(number1: int, number2: int) -&gt; int:\n    return number1 / number2\n\ndef foo8(number1: int, number2: int) -&gt; int:\n    return 2*number1 + number2\n\n# main\n\nprint(foo1(1, 2))\nprint(foo2(1, 2))\nprint(foo3(1, 2))\n\n</code></pre>"},{"location":"tutorial-example-manual/#file1py","title":"file1.py","text":"<pre><code>#IFFT.If This is a test comment\n\nprint('Hello world!')\n\n#IFFT.Then (path_to_associated_file, associated_file_ifft_label)\n</code></pre>"},{"location":"tutorial-example-manual/#step-1-running-the-tool-before-any-changes","title":"Step 1: Running the tool before any changes:","text":"<pre><code>$ python3 ifft.py \"path/to/project\"\n</code></pre> <p>As expected, we should not see any output, since the project is not changed yet. The following image illustrates this cases:</p> <p></p> <p>Note: The default project is the \"mock_project\", so the [dir_name] parameter was not passed.</p>"},{"location":"tutorial-example-manual/#step-2-making-a-change-outside-a-ifft-block","title":"Step 2: Making a change outside a IFFT block:","text":"<p>We'll add a new function inside the <code>app.py</code> file, outside any IFFT block. The new function is as follows:</p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\ndef outsideFunction() -&gt; None:\n    print(\"This is a new function added outside of any IFFT block!\")\n\n# main\n\n...\n</code></pre> <p>Given that the code was added outside the IFFT block, again, the tool should not output anything, as shown in the image below:</p> <p></p> <p>Note that the change cannot be found in the debug output, since it is not inside an IFFT block.</p> <p>Note 1: The program executed in debug mode. In the release version, these messages won't appear.</p> <p>Note 2: Even though a function was added as a change for this tutorial, any code could be added instead.</p>"},{"location":"tutorial-example-manual/#step-3-making-a-change-inside-a-ifft-block","title":"Step 3: Making a change inside a IFFT block:","text":"<p>Now, we'll add a new function inside the <code>app.py</code> file, inside the <code>foo1</code> IFFT block. The new function is as follows:</p> <p>Just a reminder before we proceed. For this example, I already have submmited the code added in the previous step. As you can see in this 'diff' below, after the commit, we have only the new change:</p> <p></p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\ndef insideFunction() -&gt; None:\n    print(\"This is a new function added inside of an IFFT block!\")\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\n</code></pre> <p>After the change, we should see the following output (actually, a similar one given that this is the debug mode):</p> <p></p> <p>Note that now the tool detected the change and now recommends the developer to take a look at the associated file <code>file1.py</code> (more specefically in <code>foo1_related_block</code>) to see if any changes are needed.</p>"},{"location":"tutorial-example-manual/#final-message","title":"Final message","text":"<p>This is the end of the tutorial. The tool can be used in a real project to help developers to keep track of the changes and to make sure that the changes are propagated to the associated files. This tutorial isn't a exact one but it should be enough to give a glimpse of how the tool can be used in a real project.</p>"}]}