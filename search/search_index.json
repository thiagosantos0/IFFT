{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IFFT","text":"<p>IFFT is a Python linter to help you handle correlated changes across your codebase.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>./ifft.py [dir-name]</code> - Run IFFT tool in [dir_name] project.</li> </ul>"},{"location":"#project-structure","title":"Project structure","text":"<pre><code>  \u251c\u2500\u2500 banner.py\n  \u251c\u2500\u2500 docs\n  \u251c\u2500\u2500 ifft_core\n  \u2502\u00a0\u00a0 \u251c\u2500\u2500 ifft_parser.py # File with tool helper methods\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 __init__.py\n  \u251c\u2500\u2500 ifft.py # Main file that triggers the tool\n  \u251c\u2500\u2500 mkdocs.yml\n  \u251c\u2500\u2500 mock_project # Mock project to test the tool\n  \u251c\u2500\u2500 README.md\n  \u251c\u2500\u2500 requirements.txt\n  \u251c\u2500\u2500 site # Documentation\n  \u251c\u2500\u2500 surfaces\n  \u2502\u00a0\u00a0 \u2514\u2500\u2500 library\n  \u2502\u00a0\u00a0     \u2514\u2500\u2500 filler_file\n  \u2514\u2500\u2500 tests\n      \u251c\u2500\u2500 filler_file\n      \u2514\u2500\u2500 test_ifft_core.py\n</code></pre>"},{"location":"#reccomended-project-structure","title":"Reccomended project structure","text":"<pre><code>  \u2500\u2500 IFFT \n      \u251c\u2500\u2500 ifft_core \n      \u00a0 \u00a0 \u2514\u2500\u2500 ... \n      \u251c\u2500\u2500 ... \n      \u251c\u2500\u2500 ifft.py\n      \u2514\u2500\u2500 your_project \n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>This part of the project documentation focuses on an information-oriented approach. You can find all helper methods defined by the \"ifft_core\" module here. You'll find detailed information about the method signatures, return types, exceptions, and examples.</p> <p>The module contains the following functions:</p> <ul> <li><code>get_modified_lines(repo, filename) - Get a set of modified lines for the given filename.</code></li> <li><code>scan_file(project_path, filename, modified_lines_set) - Scan the file for IFFT blocks and return the results.</code></li> <li><code>scan_files(project_path, dir_path_mock_project) - Scan the repository for modified Python files and return the results in a dictionary.</code></li> <li><code>validate_associated_file(associated_file_name)</code> - Validade if the associated file specified in IFFT block exists.</li> </ul>"},{"location":"reference/#note-for-the-examples-in-this-documentation-the-plus-sign-indicates-a-modified-line","title":"Note: For the examples in this documentation, the plus sign (+) indicates a modified line.","text":""},{"location":"reference/#ifft_core.ifft_parser.get_modified_lines","title":"<code>get_modified_lines(repo, filename, auto_mode)</code>","text":"<p>Get a set of modified lines for the given filename.</p> Example <p>file1.py:</p> <pre><code>+ line1\n\n+ line2\n\n+ line3\n</code></pre> <p>get_modified_lines(repo, file1.py)</p> <p>{'line1', 'line2', 'line3'}</p> <p>Parameters:</p> Name Type Description Default <code>repo</code> <code>str</code> <p>A string corresponding to the repository.</p> required <code>filename</code> <code>str</code> <p>A string corresponding to the filename.</p> required <p>Returns:</p> Name Type Description <code>set</code> <code>set</code> <p>A set of modified lines.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def get_modified_lines(repo: str, filename: str, auto_mode: argparse.Namespace) -&gt; set:\n    \"\"\"\n        Get a set of modified lines for the given filename.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                + line1\\n\n                + line2\\n\n                + line3\n\n            &gt;&gt;&gt;get_modified_lines(repo, file1.py)\\n\n            {'line1', 'line2', 'line3'}\n\n        Args:\n            repo (str): A string corresponding to the repository.\n            filename (str): A string corresponding to the filename.\n\n        Returns:\n            set: A set of modified lines.\n\n    \"\"\"\n    modified_lines = set()\n    diff_text = \"\"\n\n    if not auto_mode:\n        diff_text = repo.git.diff(None, filename)\n\n    else:\n        diff_text = repo.git.diff('HEAD', filename)\n\n    logging.info(f\"{Fore.BLUE} DIFF TEXT: {diff_text} {Style.RESET_ALL}\")\n    logging.info(f\"{Fore.BLUE} REPO: {repo} {Style.RESET_ALL}\")\n    logging.info(f\"{Fore.BLUE} FILENAME: {filename} {Style.RESET_ALL}\")\n\n    diff_lines = diff_text.split('\\n')\n    line_number = 0\n\n    for line in diff_lines:\n        if line.startswith('@@'):\n            line_number = int(line.split()[2].split(',')[0].replace('+', ''))\n        elif line.startswith('+') and not line.startswith('+++'):\n            modified_lines.add((line_number, line[1:].strip()))\n            line_number += 1\n        elif line.startswith(' '):\n            line_number += 1\n\n    logging.info(f\"{Fore.GREEN} Modified lines: {modified_lines} {Style.RESET_ALL}\")\n    return modified_lines\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.scan_file","title":"<code>scan_file(project_path, filename, modified_lines_set)</code>","text":"<p>Scan the file for IFFT blocks and return the results.</p> Example <p>file1.py:</p> <pre><code>#IFFT.If\n\n    + line1\n\n    + line2\n\n    + line3\n#IFFT.Then(\"foo_file.py\", \"foo_label\")\n</code></pre> <p>scan_file(project_path, file1.py, {'line1', 'line2', 'line3'})</p> <pre><code>[{'block_content': '...',\n  'associated_file_name': 'foo_file.py',\n  'associated_file_label': 'foo_label',\n  'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>A string corresponding to the project path.</p> required <code>filename</code> <code>str</code> <p>A string corresponding to the filename.</p> required <code>modified_lines_set</code> <code>set</code> <p>A set of modified lines.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of results.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def scan_file(project_path: str, filename: str, modified_lines_set: set) -&gt; list:\n    \"\"\"\n        Scan the file for IFFT blocks and return the results.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                #IFFT.If\\n\n                    + line1\\n\n                    + line2\\n\n                    + line3\n                #IFFT.Then(\"foo_file.py\", \"foo_label\")\n\n            &gt;&gt;&gt;scan_file(project_path, file1.py, {'line1', 'line2', 'line3'})\\n\n                [{'block_content': '...',\n                  'associated_file_name': 'foo_file.py',\n                  'associated_file_label': 'foo_label',\n                  'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n\n        Args:\n            project_path (str): A string corresponding to the project path.\n            filename (str): A string corresponding to the filename.\n            modified_lines_set (set): A set of modified lines.\n\n        Returns:\n            list: A list of results.\n\n    \"\"\"\n\n    results = []\n    in_block = False\n    block_content = \"\"\n    associated_file = \"\"\n    block_start = 0\n    block_end = 0\n    modified_lines_within_blocks = []\n\n    logging.debug(f\"{Fore.GREEN} Scanning file: {filename} {Style.RESET_ALL}\")\n    file_path = os.path.join(project_path, filename)\n    logging.debug(f\"{Fore.GREEN} File path: {file_path} {Style.RESET_ALL}\")\n    logging.debug(f\"{Fore.GREEN} Modified lines set: {modified_lines_set} {Style.RESET_ALL}\")\n\n\n    with open(file_path) as f:\n        lines = f.readlines()\n\n    ifft_if_pattern = re.compile(r'#\\s*IFFT\\.If', re.IGNORECASE)\n    ifft_then_pattern = re.compile(r'#\\s*IFFT\\.Then\\(\\s*\"([^\"]+)\"\\s*,\\s*\"([^\"]+)\"\\s*\\)', re.IGNORECASE)\n\n    for line_number, line in enumerate(lines):\n        if ifft_if_pattern.search(line.strip()):\n            logging.debug(f\"{Fore.GREEN} Entering IFFT block {line} {Style.RESET_ALL}\")\n            in_block = True\n            block_start = line_number\n            block_content += line\n            # block reset\n            modified_lines_within_blocks = []\n\n        elif ifft_then_pattern.search(line):\n            logging.info(f\"{Fore.YELLOW} Exiting IFFT block {line} + {Style.RESET_ALL}\")\n            match = ifft_then_pattern.search(line)\n            print(f\"Match: {match}\")\n            associated_file_name = match.group(1)\n            associated_file_label = match.group(2)\n            valid_associated_file = validate_associated_file(associated_file_name)\n            if not valid_associated_file:\n                associated_file_name = \"\"\n                associated_file_label = \"\"\n            logging.info(f\"{Fore.YELLOW} Associated file name: {associated_file_name} {Style.RESET_ALL}\")\n            logging.info(f\"{Fore.YELLOW} Associated file label: {associated_file_label} {Style.RESET_ALL}\")\n            block_end = line_number\n\n            results.append({\n                \"block_content\": block_content,\n                \"associated_file_name\": associated_file_name,\n                \"associated_file_label\": associated_file_label,\n                \"modified_lines_within_block\": modified_lines_within_blocks\n            })\n\n            logging.info(f\"{Fore.YELLOW} Block content: \\n{block_content} {Style.RESET_ALL}\")\n            logging.info(f\"{Fore.YELLOW} Block end found at line: {block_end} {Style.RESET_ALL}\")\n            in_block = False\n            block_content = \"\"\n\n        elif in_block:\n            block_content += line\n            line_stripped = line.strip()\n            if (line_number + 1, line_stripped) in modified_lines_set:\n                logging.debug(f\"Line number: {line_number + 1} Line: {line_stripped}\")\n                modified_lines_within_blocks.append(line_stripped)\n\n    return results\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.scan_files","title":"<code>scan_files(project_path=dir_path_mock_project, auto_mode=None)</code>","text":"<p>Scan the repository for modified Python files and return the results in a dictionary.</p> Example <p>file1.py:</p> <pre><code>#IFFT.If\n\n    + line1\n\n    + line2\n\n    + line3\n#IFFT.Then(\"foo_file.py\", \"foo_label\")\n</code></pre> <p>file2.py:</p> <pre><code>#IFFT.If\n\n    + line4\n\n    + line5\n\n    + line6\n#IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n</code></pre> <p>scan_files(project_path)</p> <pre><code>{'file1.py': [{'block_content': '...',\n               'associated_file_name': 'foo_file.py',\n               'associated_file_label': 'foo_label',\n               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n    'file2.py': [{'block_content': '...',\n                'associated_file_name': 'foo_file2.py',\n               'associated_file_label': 'foo_label2',\n               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>project_path</code> <code>str</code> <p>A string corresponding to the project path.</p> <code>dir_path_mock_project</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of results.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def scan_files(project_path: str = dir_path_mock_project, auto_mode: argparse.Namespace = None) -&gt; dict:\n    \"\"\"\n        Scan the repository for modified Python files and return the results in a dictionary.\n\n        Example:\n            &gt;&gt;&gt;file1.py:\\n\n                #IFFT.If\\n\n                    + line1\\n\n                    + line2\\n\n                    + line3\n                #IFFT.Then(\"foo_file.py\", \"foo_label\")\n            &gt;&gt;&gt;file2.py:\\n\n                #IFFT.If\\n\n                    + line4\\n\n                    + line5\\n\n                    + line6\n                #IFFT.Then(\"foo_file2.py\", \"foo_label2\")\n\n            &gt;&gt;&gt;scan_files(project_path)\\n\n                {'file1.py': [{'block_content': '...',\n                               'associated_file_name': 'foo_file.py',\n                               'associated_file_label': 'foo_label',\n                               'modified_lines_within_block': {'line1', 'line2', 'line3'}}]\n                    'file2.py': [{'block_content': '...',\n                                'associated_file_name': 'foo_file2.py',\n                               'associated_file_label': 'foo_label2',\n                               'modified_lines_within_block': {'line4', 'line5', 'line6'}}]}\n\n        Args:\n            project_path (str): A string corresponding to the project path.\n\n        Returns:\n            dict: A dictionary of results.\n\n    \"\"\"\n\n    results_dict = {}\n    try:\n        repo = Repo(project_path)\n    except NoSuchPathError:\n        logging.error(f\"{Fore.RED} The path '{project_path}' does not exist. {Style.RESET_ALL}\")\n        return results_dict\n    except InvalidGitRepositoryError:\n        logging.error(f\"{Fore.RED} The path '{project_path}' is not a valid Git repository. {Style.RESET_ALL}\")\n        return results_dict\n    except Exception as e:\n        logging.error(f\"{Fore.RED} Failed to load repository: {e} {Style.RESET_ALL}\")\n        return results_dict\n\n    modified_files = []\n    if not auto_mode:\n        modified_files = [item.a_path for item in repo.index.diff(None)]\n    else:\n        modified_files = get_modified_files()\n\n    logging.info(f\"{Fore.GREEN} Modified files found {modified_files}\")\n\n    for filename in modified_files:\n        if filename.endswith(\".py\"):\n            logging.info(f\"{Fore.GREEN} FIRST CHECKPOINT {Style.RESET_ALL}\")\n            modified_lines_set = get_modified_lines(repo, filename, auto_mode)\n            results_dict[filename] = scan_file(project_path, filename, modified_lines_set)\n\n\n    logging.info(f\"{Fore.GREEN} SECOND CHECKPOINT {Style.RESET_ALL}\")\n    return results_dict\n</code></pre>"},{"location":"reference/#ifft_core.ifft_parser.validate_associated_file","title":"<code>validate_associated_file(associated_file_name)</code>","text":"<p>Validate if the associated file specified in IFFT block exists.</p> Example <p>validate_associated_file(\"foo_file.py\") True</p> <p>validate_associated_file(\"foo_file2.py\") False</p> <p>Parameters:</p> Name Type Description Default <code>associated_file_name</code> <code>String</code> <p>A string corresponding to the file beeing verified.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>A boolean that indicate whether the specified file is valid or not.</p> Source code in <code>ifft_core/ifft_parser.py</code> <pre><code>def validate_associated_file(associated_file_name: str) -&gt; bool:\n    \"\"\"\n        Validate if the associated file specified in IFFT block exists.\n\n        Example:\n            &gt;&gt;&gt;validate_associated_file(\"foo_file.py\")\n            True\n\n            &gt;&gt;&gt;validate_associated_file(\"foo_file2.py\")\n            False\n\n        Args:\n            associated_file_name (String): A string corresponding to the file beeing\n                verified.\n\n        Returns:\n            bool: A boolean that indicate whether the specified file is valid or not.\n    \"\"\"\n\n    project_path = os.path.join(dir_path_mock_project)\n    associated_file_name = associated_file_name.replace('\"', '')\n    file_path = os.path.join(project_path, associated_file_name)\n    if not os.path.isfile(file_path):\n        logging.error(f\"{Fore.RED} Associated file: {associated_file_name} not found {Style.RESET_ALL}\")\n        logging.error(f\"{Fore.RED} Associated file path: {file_path} {Style.RESET_ALL}\")\n        return False\n    logging.info(f\"{Fore.YELLOW} Associated file: {associated_file_name} found {Style.RESET_ALL}\")\n    return True\n</code></pre>"},{"location":"tutorial-example-automode/","title":"Example - Automode","text":"<p>This section of documentaion consists in step-by-step example of the code usage in mock project using automode. The idea here is to give a glimpse of how the tool can be used in a real project.</p> <p>Here is the following <code>mock project</code> structure:</p> <pre><code>../mock_project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 file1.py\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The content of the files are as follows:</p>"},{"location":"tutorial-example-automode/#apppy","title":"app.py","text":"<pre><code>import os\n\nfile_dir = os.path.dirname(__file__)\n\n\n#IFFT.If(foo1 block)\ndef foo1(number1: int, number2: int) -&gt; int:\n    # Adding a change for testing purposes\n    return number1 + number2\n\n# Adding a change for testing purposes\n\ndef foo5(number1: int, number2: int) -&gt; int:\n    return number1 ** number2\n\ndef foo6(number1: int, number2: int) -&gt; int:\n    return number1 % number2\n\ndef foo7(number1: int, number2: int) -&gt; int:\n    return number1 // number2\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\ndef foo2(number1: int, number2: int) -&gt; int:\n    return number1 - number2\n\ndef foo3(number1: int, number2: int) -&gt; int:\n    return number1 * number2\n\ndef foo4(number1: int, number2: int) -&gt; int:\n    return number1 / number2\n\ndef foo8(number1: int, number2: int) -&gt; int:\n    return 2*number1 + number2\n\n# main\n\nprint(foo1(1, 2))\nprint(foo2(1, 2))\nprint(foo3(1, 2))\n\n</code></pre>"},{"location":"tutorial-example-automode/#file1py","title":"file1.py","text":"<pre><code>#IFFT.If This is a test comment\n\nprint('Hello world!')\n\n#IFFT.Then (path_to_associated_file, associated_file_ifft_label)\n</code></pre>"},{"location":"tutorial-example-automode/#step-0-pre-commit-configuration","title":"Step 0: pre-commit configuration","text":"<p>In order to use IFFT in automode all you have to do is create a pre-commit file for your project. You can find a pre-filled template that should cover the great majority of the use cases:</p> <pre><code>#!/bin/bash\n\n# This is a pre-commit template configuration that can be used for any project with\n# just minor changes\n\nPROJECT_DIR=$(pwd)\n\n# Path to the IFFT script \nIFFT_SCRIPT_PATH=\"../ifft.py\"\n\n# Checking for Python files in staging area\nSTAGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\\.py$')\n\n# If we don't have any staged files, the program can end\nif [ -z \"$STAGED_FILES\" ]; then\n    exit 0\nfi\n\n# Now going to the project directory\ncd \"$PROJECT_DIR\"\n\n# Running IFFT script with auto_mode flag and getting the output\nOUTPUT=$(python3 \"$IFFT_SCRIPT_PATH\" --auto 2&gt;&amp;1)\nIFFT_EXIT_CODE=$?\n\n# Show the output\necho \"$OUTPUT\"\n\n# Check IFFT output\n# If auto_mode is beeing used and a change is identified inside a IFFT block\n# the program will ask (before commit - this is the reason why this bash script\n# is for pre-commit hook) if he wants to continue with te commit or abort.\nif [ $IFFT_EXIT_CODE -ne 0 ]; then\n    echo \"IFFT check detected changes in the blocks.\"\n\n    read -p \"Changes detected in IFFT blocks. Do you want to continue with the commit? (y/n): \" CONTINUE_COMMIT &lt; /dev/tty\n\n    if [[ \"$CONTINUE_COMMIT\" != \"y\" &amp;&amp; \"$CONTINUE_COMMIT\" != \"Y\" ]]; then\n        echo \"Commit aborted.\"\n        exit 1\n    fi\nfi\n\n# Succesfull execution\nexit 0\n\n</code></pre> <p>If you project structure is following the recommended pattern (can be found documentation main page), all you have to fill out is the path to ifft script and it's all setup.</p>"},{"location":"tutorial-example-automode/#step-1-checking-if-the-auto-mode-is-enabled","title":"Step 1: Checking if the \"auto-mode\" is enabled","text":"<p>You can run the following command on your terminal or alternatively, you can open it in any text editor.</p> <pre><code>$ cat ifft_config.json\n</code></pre> <p>You should see something like this: </p> <p>This is where IFFT configuration can be changed, as this tutorial aims to show how automode works I will switch it to true.</p>"},{"location":"tutorial-example-automode/#step-2-triggering-the-tool","title":"Step 2: Triggering the tool","text":"<p>The main idea of automode is to run IFFT automatically. More especifically just before the  creation of a commit. In automode IFFT will run every time a new commit is created and will give you one of the two outputs:   - A message saying that none change was found inside a IFFT block.     - Commit is made normally.</p> <ul> <li>A message saying that changes were found inside IFFT blocks and asking you     if you want to continue with the commit anyways or to abort:<ul> <li>If you take (y) as option (anything different of (n or N) actually) the commit action   will happen normally.</li> </ul> </li> </ul> <p>Thats the process in summary. Now, follow the practical examples:</p>"},{"location":"tutorial-example-automode/#step-1-making-a-change-outside-a-ifft-block","title":"Step 1: Making a change outside a IFFT block:","text":"<p>We'll add a new function inside the <code>app.py</code> file, outside any IFFT block. The new function is as follows:</p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\ndef outsideFunction() -&gt; None:\n    print(\"This is a new function added outside of any IFFT block!\")\n\n# main\n\n...\n</code></pre> <p>After the change addition, we have the following as the output for git status command:</p> <pre><code>$ git status \n</code></pre> <p></p> <p>As mentioned before, we need to proceed to do a commit in order to have the tool automatically triggered, this is done as follow:</p> <pre><code>$ git add app.py\n$ git commit -m \"Commit message\"\n</code></pre> <p>As soon as we run the commit command, we should have the feature triggering automatically and, in this case, we should have something like this: </p> <p>Note that the change cannot be found in the debug output, since it is not inside an IFFT block. For this reason the program just show a empty list of modified lines inside IFFT block and says that \"No changes detected in IFFT blocks\". </p> <p>Note 1: You can ignore this .env file for this example. Note 2: Please note that the commit is done normally in this case.</p>"},{"location":"tutorial-example-automode/#step-2-making-a-change-inside-a-ifft-block","title":"Step 2: Making a change inside a IFFT block:","text":"<p>Now, we'll add a new function inside the <code>app.py</code> file, inside the <code>foo1</code> IFFT block. The new function is as follows:</p> <p>Just a reminder before we proceed. In this stage, we have already commited the first change (outside one) so it will not appear in the diff for this section.</p> <p></p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\ndef insideFunction() -&gt; None:\n    print(\"This is a new function added inside of an IFFT block!\")\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\n</code></pre> <p>Again, doing the same process of the last example (git add followed by git commit command) we have the following:</p> <p></p> <p>Note that now the tool detected the change and now recommends the developer to take a look at the associated file <code>file1.py</code> (more specefically in <code>foo1_related_block</code>) to see if any changes are needed.</p> <p>Not only that, now the tool also asks the developer if he wants to go on with his commit or abort the commit. If it's the case where the developer didn't know that those two files are related or forgot about it, normally he will at least check if everything is ok, so he'll probably abort it at first. After take a look in the code and change what is necessary or he came to an conclusion that a change is not necessary, he can go on with the commit.</p>"},{"location":"tutorial-example-automode/#final-message","title":"Final message","text":"<p>This is the end of the tutorial. The tool can be used in a real project to help developers to keep track of the changes and to make sure that the changes are propagated to the associated files. This tutorial isn't a exact one but it should be enough to give a glimpse of how the tool can be used in a real project.</p>"},{"location":"tutorial-example-manual/","title":"Example - Manual","text":"<p>This section of documentaion consists in step-by-step example of the code usage in mock project using manual mode. The idea here is to give a glimpse of how the tool can be used in a real project.</p> <p>Here is the following <code>mock project</code> structure:</p> <pre><code>../mock_project/\n\u251c\u2500\u2500 app.py\n\u251c\u2500\u2500 file1.py\n\u2514\u2500\u2500 README.md\n</code></pre> <p>The content of the files are as follows:</p>"},{"location":"tutorial-example-manual/#apppy","title":"app.py","text":"<pre><code>import os\n\nfile_dir = os.path.dirname(__file__)\n\n\n#IFFT.If(foo1 block)\ndef foo1(number1: int, number2: int) -&gt; int:\n    # Adding a change for testing purposes\n    return number1 + number2\n\n# Adding a change for testing purposes\n\ndef foo5(number1: int, number2: int) -&gt; int:\n    return number1 ** number2\n\ndef foo6(number1: int, number2: int) -&gt; int:\n    return number1 % number2\n\ndef foo7(number1: int, number2: int) -&gt; int:\n    return number1 // number2\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\ndef foo2(number1: int, number2: int) -&gt; int:\n    return number1 - number2\n\ndef foo3(number1: int, number2: int) -&gt; int:\n    return number1 * number2\n\ndef foo4(number1: int, number2: int) -&gt; int:\n    return number1 / number2\n\ndef foo8(number1: int, number2: int) -&gt; int:\n    return 2*number1 + number2\n\n# main\n\nprint(foo1(1, 2))\nprint(foo2(1, 2))\nprint(foo3(1, 2))\n\n</code></pre>"},{"location":"tutorial-example-manual/#file1py","title":"file1.py","text":"<pre><code>#IFFT.If This is a test comment\n\nprint('Hello world!')\n\n#IFFT.Then (path_to_associated_file, associated_file_ifft_label)\n</code></pre>"},{"location":"tutorial-example-manual/#step-1-running-the-tool-before-any-changes","title":"Step 1: Running the tool before any changes:","text":"<pre><code>$ python3 ifft.py \"path/to/project\"\n</code></pre> <p>As expected, we should not see any output, since the project is not changed yet. The following image illustrates this cases:</p> <p></p> <p>Note: The default project is the \"mock_project\", so the [dir_name] parameter was not passed.</p>"},{"location":"tutorial-example-manual/#step-2-making-a-change-outside-a-ifft-block","title":"Step 2: Making a change outside a IFFT block:","text":"<p>We'll add a new function inside the <code>app.py</code> file, outside any IFFT block. The new function is as follows:</p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\ndef outsideFunction() -&gt; None:\n    print(\"This is a new function added outside of any IFFT block!\")\n\n# main\n\n...\n</code></pre> <p>Given that the code was added outside the IFFT block, again, the tool should not output anything, as shown in the image below:</p> <p></p> <p>Note that the change cannot be found in the debug output, since it is not inside an IFFT block.</p> <p>Note 1: The program executed in debug mode. In the release version, these messages won't appear.</p> <p>Note 2: Even though a function was added as a change for this tutorial, any code could be added instead.</p>"},{"location":"tutorial-example-manual/#step-3-making-a-change-inside-a-ifft-block","title":"Step 3: Making a change inside a IFFT block:","text":"<p>Now, we'll add a new function inside the <code>app.py</code> file, inside the <code>foo1</code> IFFT block. The new function is as follows:</p> <p>Just a reminder before we proceed. For this example, I already have submmited the code added in the previous step. As you can see in this 'diff' below, after the commit, we have only the new change:</p> <p></p> <pre><code>import os\nfile_dir = os.path.dirname(__file__)\n\n#IFFT.If(foo1 block)\n\n...\n\ndef insideFunction() -&gt; None:\n    print(\"This is a new function added inside of an IFFT block!\")\n\n#IFFT.Then(\"file1.py\", \"foo1_related_block\")\n\n...\n\n</code></pre> <p>After the change, we should see the following output (actually, a similar one given that this is the debug mode):</p> <p></p> <p>Note that now the tool detected the change and now recommends the developer to take a look at the associated file <code>file1.py</code> (more specefically in <code>foo1_related_block</code>) to see if any changes are needed.</p>"},{"location":"tutorial-example-manual/#final-message","title":"Final message","text":"<p>This is the end of the tutorial. The tool can be used in a real project to help developers to keep track of the changes and to make sure that the changes are propagated to the associated files. This tutorial isn't a exact one but it should be enough to give a glimpse of how the tool can be used in a real project.</p>"}]}